Spring
概念:分层的轻量级开源框架,以Ioc和AOP为内核,在不同的业务场景中Spring都为我们提供了相应的解决方案
优势:简化开发,降低企业级开发的复杂性
    框架整合,正因为企业开发中使用的框架越来越多,无疑提高了项目的复杂度,Spring的出现实现了高效整合其他框架,提高了企业级应用开发与运行效率
实现简化开发:Ioc和AOP,事务处理
可整合主流框架包括:Mybatis(重点),Mybatis-plus,Struts,Struts2,Hibernate等
-------------------------------------------------------------------------------------------------------------------------
Spring Framework(框架)
概念:是Spring生态圈中最基础的项目,是其他项目的根基
-------------------------------------------------------------------------------------------------------------------------
IoC/DI(目的就是为了充分解耦)
Mybatis开发时的现状:Service层里的一个方法对应Mapper层的一个接口方法,在调用mapper里方法时必须创建对象,如果一个已经部署的项目想修改Mapper层的方法时,
Service层里的对象也要进行修改再重新部署,耦合度较高

解决方案:Service层不主动创建对象,直接使用"外部"提供的对象(这样一种思想称为IoC->控制反转)
->Spring为我们的思想进行了实现:Spring为我们提供了一个名为IoC的容器,充当上文的"外部"
  IoC容器中不仅可以存放mapper对象,还可以存放Service对象(毕竟Controller层也需要创建service对象)
  IoC容器负责对象的创建,初始化等一系列工作,容器内的对象统称为Bean

仍存在的问题:IoC在Controller层可以直接为我们提供service对象,Service层又为我们直接提供mapper对象,而一个service服务可能依赖一个mapper的方法也可能
           是多个;这样导致耦合度仍然较高

解决方案:我们事先将service对象与需要的mapper进行绑定(这样一种思想称为DI[Dependency Injection])->依赖注入),通过配置的方式
-------------------------------------------------------------------------------------------------------------------------
新的项目结构问题:为什么service层和dao层都要编写接口和实现类?
答:归根结底就是要解耦,直接写类固然会节省很多代码,但是灵活度没有前者高,如果是比较简单的业务需求(比如简单的增删查改),直接写会比较方便,若是比较复杂的
   业务逻辑,或者说用户的需求发生了很大的变化,我们与其修改整个类,不如修改接口的实现类,这样提高了效率
-------------------------------------------------------------------------------------------------------------------------
Idea集成Spring->在pom.xml里添加Spring依赖即可
配置方法:要想把service和dao对象传给IoC管理,我们要先创建配置文件告诉Spring->在resources文件夹里创建applicationContext.xml->配置bean
使用方法:1.获取IoC容器:ApplicationContext ctx=new ClassPathXmlApplicationContext("applicationContext.xml"); 参数里放入我们写好的配置文件"说明书"
        2.获取bean:通过我们获取的容器,直接使用它的getBean(bean名)方法即可
Bean的别名:在bean标签里添加name字段即可,这样就可以在取出容器里的对象时自由度更高
正常来说,如果我们用两个对象接收同一个容器里的对象时地址是相同的(单例),这样做为了节省内存  使之不同的方法:在bean标签里加入scope字段,参数为prototype
-------------------------------------------------------------------------------------------------------------------------
适合交给容器进行管理的bean类型
1.表现层对象
2.业务层对象
3.数据层对象
4.工具类对象
不适合交给容器进行管理的bean类型:封装实体的域对象
-------------------------------------------------------------------------------------------------------------------------
实例化bean的方式(Spring如何获取IoC容器里的对象)
1.通过调用对应类的构造方法获取对象
2.静态工厂获取bean
-------------------------------------------------------------------------------------------------------------------------
bean生命周期的控制
先在实现类里编写好init和destroy方法,再通过配置文件里对应的bean标签里添加init-method和destroy-method字段,参数里填实现类里的方法名即可
在java虚拟机关闭之前需要先关闭容器,而Spring为我们提供了两种关闭方法:
->直接使用父类ClassPathXmlApplicationContext的close方法强制关闭
->在获取容器后,使用registerShutdownHook()方法添加容器钩子,它会使虚拟机关闭前自动关闭容器
更好的方法:在Service里直接实现InitializingBean,DisposableBean类,重写他们的方法即可

Bean初始化的步骤:
初始化容器
1.创建对象
2.执行构造方法
3.执行属性注入(执行构造的Set方法)
4.执行bean初始化方法()->InitializingBean类的afterPropertiesSet()方法

使用bean:指向业务操作

关闭/销毁容器:执行bean的销毁方法
-------------------------------------------------------------------------------------------------------------------------
依赖注入的方式
1.普通方式(编写get方法)->setter注入(基本数据类型/引用数据类型)
  setter注入基本数据类型时,只需要在实现类定义好属性名,写好set方法,并在配置文件里写好对应的<property>标签,将原来的ref改为value即可
  引用数据类型前文已讲
2.构造方法->构造器注入(基本数据类型/引用数据类型)->推荐!!!!!!!
  在实现类里添加一个构造器(有参构造->参数就是需要注入的对象),构造体里的内容也和setter注入一致
  不过在配置文件里不再用<property>标签,而是用<constructor-arg>,字段名一样是name,ref(基本)/value(引用)
-------------------------------------------------------------------------------------------------------------------------
配置Bean的思考
虽然通过配置文件的形式吧对象之间的关系进行了绑定,但是如同<bean id="ServiceImpl" class="com.Zezai.service.impl.ServiceImpl">的书写方式
耦合度仍然很高,如果实现类参数发生了改变,配置文件也得变,所以有人提出了方案  <property type=String ref="DaoImpl"/>(直接不写参数名,用类型来辨别)
虽然解决了形参变名的耦合性问题,但如果有两个同类型的参数时也无法使用,所以需要更好的方案.
↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓↓ ↓
依赖的自动装配(只针对引用数据类型装配)
如果我们可以不用自己动手去配置bean的注入的话(也就是ref/value参数的值)可以提高很多效率
->为此Spring为我们提供了依赖的自动装配机制

自动装配的方式:仍然需要我们提供set方法,但就不需要property标签了
1.按类型(常用)
2.按名称(不推荐)
->想要ServiceImpl里自动装填DaoImpl对象的话只需在serviceImpl里添加autowire标签即可
注意:一般来说,一个bean标签对应一个实现类(DaoImpl),所以按类型type装配是有效的   即一个id参数对应一个class参数
    如果一个实现类出现了两个bean标签的话,需要按名称id装配    即两个id参数都对应一个class参数 (但是id后的参数必须和实现类里的对象名保持一致)
当自动装配和setter注入/构造器注入同时存在时,系统会默认普通注入,自动装配将会失效
-------------------------------------------------------------------------------------------------------------------------
思考:我们已经会注入引用数据类型和基本数据类型,他们都只是单一的数据,那如果我们需要注入集合,该怎么操作?(用的较少)
答:和之前的两种注入类型方法大差不差,同样要在实现类里创建成员变量以及对应的set方法,并在配置文件中添加<property>标签,但里面的格式需要注意(以数组array为例)
   <property name="array">(这个是我们自己定义的在实现类里的数组名)
      <array>(这个是标签类型)
          <value>100</value>
          <value>200</value>
          <value>300</value>
      </array>
   </property
-------------------------------------------------------------------------------------------------------------------------
第三方资源配置管理
->我们不仅可以通过IoC管理我们自己创建的实现类对象,同时第三方来的对象同样可以进行管理
方法:  //添加druid数据源数据进行管理
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
         //因为druid没有提供构造器,所以只能用setter注入(我们需要填上连接数据库的基本信息)
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/spring_db"/>
        <property name="username" value="root"/>
        <property name="password" value="123456"/>
    </bean>
    //添加其他数据源的格式一样,参数不同,可以在网上查找资料
    
优化:如果将这些数据库连接信息全写在配置文件里不易阅读,所以我们可以将<property>标签里的信息抽取出来全部放到一个单独的文件jdbc.properties里
方法:在Spring内开辟空间,使其可以加载到jdbc.properties这个文件(在配置文件里配置)
-------------------------------------------------------------------------------------------------------------------------
容器补充知识点(了解)
1.创建容器方式:->加载类路径下的配置文件(通过写入配置文件.xml方式)(常用)
             ->通过文件加载的方式    ClassPathXmlApplicationContext ctx=new FileSystemXmlApplicationContext("绝对路径")
ApplicationContext接口使Spring容器的核心接口,初始化时Bean立即加载
ClassPathXmlApplicationContext是它的实现类
-------------------------------------------------------------------------------------------------------------------------