Spring
概念:分层的轻量级开源框架,以Ioc和AOP为内核,在不同的业务场景中Spring都为我们提供了相应的解决方案
优势:简化开发,降低企业级开发的复杂性
    框架整合,正因为企业开发中使用的框架越来越多,无疑提高了项目的复杂度,Spring的出现实现了高效整合其他框架,提高了企业级应用开发与运行效率
实现简化开发:Ioc和AOP,事务处理
可整合主流框架包括:Mybatis(重点),Mybatis-plus,Struts,Struts2,Hibernate等
-------------------------------------------------------------------------------------------------------------------------
Spring Framework(框架)
概念:是Spring生态圈中最基础的项目,是其他项目的根基
-------------------------------------------------------------------------------------------------------------------------
IoC/DI(目的就是为了充分解耦)
Mybatis开发时的现状:Service层里的一个方法对应Mapper层的一个接口方法,在调用mapper里方法时必须创建对象,如果一个已经部署的项目想修改Mapper层的方法时,
Service层里的对象也要进行修改再重新部署,耦合度较高

解决方案:Service层不主动创建对象,直接使用"外部"提供的对象(这样一种思想称为IoC->控制反转)
->Spring为我们的思想进行了实现:Spring为我们提供了一个名为IoC的容器,充当上文的"外部"
  IoC容器中不仅可以存放mapper对象,还可以存放Service对象(毕竟Controller层也需要创建service对象)
  IoC容器负责对象的创建,初始化等一系列工作,容器内的对象统称为Bean

仍存在的问题:IoC在Controller层可以直接为我们提供service对象,Service层又为我们直接提供mapper对象,而一个service服务可能依赖一个mapper的方法也可能
           是多个;这样导致耦合度仍然较高

解决方案:我们事先将service对象与需要的mapper进行绑定(这样一种思想称为DI[Dependency Injection])->依赖注入),通过配置的方式
-------------------------------------------------------------------------------------------------------------------------
新的项目结构问题:为什么service层和dao层都要编写接口和实现类?
答:归根结底就是要解耦,直接写类固然会节省很多代码,但是灵活度没有前者高,如果是比较简单的业务需求(比如简单的增删查改),直接写会比较方便,若是比较复杂的
   业务逻辑,或者说用户的需求发生了很大的变化,我们与其修改整个类,不如修改接口的实现类,这样提高了效率
-------------------------------------------------------------------------------------------------------------------------
Idea集成Spring->在pom.xml里添加Spring依赖即可
配置方法:要想把service和dao对象传给IoC管理,我们要先创建配置文件告诉Spring->在resources文件夹里创建applicationContext.xml->配置bean
使用方法:1.获取IoC容器:ApplicationContext ctx=new ClassPathXmlApplicationContext("applicationContext.xml"); 参数里放入我们写好的配置文件"说明书"
        2.获取bean:通过我们获取的容器,直接使用它的getBean(bean名)方法即可
Bean的别名:在bean标签里添加name字段即可,这样就可以在取出容器里的对象时自由度更高
正常来说,如果我们用两个对象接收同一个容器里的对象时地址是相同的(单例),这样做为了节省内存  使之不同的方法:在bean标签里加入scope字段,参数为prototype
-------------------------------------------------------------------------------------------------------------------------
适合交给容器进行管理的bean类型
1.表现层对象
2.业务层对象
3.数据层对象
4.工具类对象
不适合交给容器进行管理的bean类型:封装实体的域对象
-------------------------------------------------------------------------------------------------------------------------
实例化bean的方式(Spring如何获取IoC容器里的对象)
1.通过调用对应类的构造方法获取对象
2.静态工厂获取bean
-------------------------------------------------------------------------------------------------------------------------
bean生命周期的控制
先在实现类里编写好init和destroy方法,再通过配置文件里对应的bean标签里添加init-method和destroy-method字段,参数里填实现类里的方法名即可
在java虚拟机关闭之前需要先关闭容器,而Spring为我们提供了两种关闭方法:
->直接使用父类ClassPathXmlApplicationContext的close方法强制关闭
->在获取容器后,使用registerShutdownHook()方法添加容器钩子,它会使虚拟机关闭前自动关闭容器
更好的方法:在Service里直接实现InitializingBean,DisposableBean类,重写他们的方法即可

Bean初始化的步骤:
初始化容器
1.创建对象
2.执行构造方法
3.执行属性注入(执行构造的Set方法)
4.执行bean初始化方法()->InitializingBean类的afterPropertiesSet()方法

使用bean:指向业务操作

关闭/销毁容器:执行bean的销毁方法
-------------------------------------------------------------------------------------------------------------------------
依赖注入的方式
1.普通方式(编写get方法)->setter注入(基本数据类型/引用数据类型)
  setter注入基本数据类型时,只需要在实现类定义好属性名,写好set方法,并在配置文件里找到对应的bean标签,将原来的ref改为value即可
  引用数据类型前文已讲
2.构造方法->构造器注入(基本数据类型/引用数据类型)->推荐!!!!!!!
  在实现类里添加一个构造器(有参构造->参数就是需要注入的对象),构造体里的内容也和setter注入一致
  不过在配置文件里不再用<property>标签,而是用<constructor-arg>,字段名一样是name,ref(基本)/value(引用)
-------------------------------------------------------------------------------------------------------------------------
配置Bean的思考
虽然通过配置文件的形式吧对象之间的关系进行了绑定,但是如同<bean id="ServiceImpl" class="com.Zezai.service.impl.ServiceImpl">的书写方式
耦合度仍然很高,如果实现类参数发生了改变,配置文件也得变,所以有人提出了方案  <property type=String ref="DaoImpl"/>(直接不写参数名,用类型来辨别)
虽然解决了形参变名的耦合性问题,但如果有两个同类型的参数时也无法使用,所以需要更好的方案.